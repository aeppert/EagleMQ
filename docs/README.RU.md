EagleMQ
========

EagleMQ это открытый, высокопроизводительный и легковесный менеджер очередей.

Базовые команды
===============
* .auth
* .ping
* .stat
* .save
* .flush
* .disconnect

Описание базовых команд
======================
.auth(name, password)
---------------------------------
Команда *.auth* используется для аутентификации клиента на сервере.

*name* - имя пользователя

*password* - пароль пользователя

Имя пользователя *name* и пароль *password* не может иметь длину больше 32.

.ping
--------
Команда *.ping* отправляет серверу ping сообщение и получает ответ.
Используется для проверки состояния сервера.

Для выполнения данной команды не требуется аутентификация на сервере.

.stat
-------
Команда *.stat* используется для получения статистики сервера.

Сервер предоставляет следующую статистику:

* Version major, minor, patch - информация о версии сервера
* Uptime - время в секундах с начала запуска
* Used CPU [system, user] - использование процессора
* Used [memory, memory RSS] - используемая память
* Memory fragmentation ratio - информация об уровне фрагментации памяти
* Clients - количество подключенных клиентов
* Users - количество пользователей
* Queues - количество очередей

.save(async)
------------
Команда *.save* используется для сохранения данных на диск.

*async* устанавливает режим использования.

Если *async* равен 0 - использовать синхронное сохранение данных.

Если *async* равен 1 - использовать асинхронное сохранение данных.

.flush(flags)
----------------
Команда *.flush* используется для принудительного удаления данных с сервера.

Флаги *flags* являются битовой последовательностью.
Флаги *flags* могут принимать 2 значения - FLUSH\_USER или FLUSH\_QUEUE.

Флаг FLUSH\_USER указывает что будут удалены все пользователи (кроме главного администратора).

Флаг FLUSH\_QUEUE указывает что будут удалены все очереди.

Рекомендуется использовать данную команду только когда нужно удалить все данные с сервера.

.disconnect
-----------------
Команда *.disconnect* отсоединяет клиента от сервера.

Для выполнения данной команды не требуется аутентификация на сервере.

Пользователи
============
EagleMQ является многопользовательской системой и позволяет иметь неограниченное количество пользователей.
Пользователи используются для ограничения действий аутентифицированного клиента с целью обезопасить данные.
Например можно создать пользователя который будет иметь права только на создание и удаление очередей.
Использование пользователей является хорошим тоном при разработке многокомпонентных систем где каждый компонент выполняет определённую задачу на сервере. По умолчанию имя пользователя и пароль - eagle/eagle.

Команды для работы с пользователями
====================================
* .user\_create
* .user\_list
* .user\_rename
* .user\_set\_perm
* .user\_delete

Описание команд для работы с пользователями
==========================================
.user\_create(name, password, perm)
-----------------------------------------------------
Команда *.user\_create* создает пользователя с именем *name*, паролем *password* и правами *perm*.

Права *perm* являются битовой последовательностью. Поддерживаемые права пользователя см. в таблице 1.

Имя пользователя *name* и пароль *password* не может иметь длину больше 32.

.user\_list
-------------
Команда *.user\_list* используется для получения списка пользователей.

Сервер предоставляет следующую информацию о пользователе:

* name - имя пользователя
* password - пароль пользователя
* permissions - права пользователя

.user\_rename(from, to)
----------------------------------
Команда *.user\_rename* переименовывает пользователя с именем *from* в *to*.

Имя пользователя *from* и *to* не может иметь длину больше 32.

.user\_set\_perm(name, perm)
--------------------------------------------
Команда *.user\_set\_perm* устанавливает новые права *perm* пользователю с именем *name*.

Новые права вступят в силу после повторной аутентификации пользователя.

Имя пользователя *name* не может иметь длину больше 32.

.user\_delete(name)
----------------------------
Команда *.user\_delete* удаляет пользователя с именем *name*.

Имя пользователя *name* не может иметь длину больше 32.

Таблица 1. Описание прав пользователя
-------------------------------------------------------------
<table border="1">
    <tr>
        <td><b>№</b></td>
        <td><b>Название</b></td>
        <td><b>Номер бита</b></td>
        <td><b>Команда</b></td>
        <td><b>Описание</b></td>
    </tr>
    <tr>
        <td>1</td>
        <td>QUEUE_PERM</td>
        <td>0</td>
        <td>
            <i>.queue_create</i><br/>
            <i>.queue_declare</i><br/>
            <i>.queue_exist</i><br/>
            <i>.queue_list</i><br/>
            <i>.queue_rename</i><br/>
            <i>.queue_size</i><br/>
            <i>.queue_push</i><br/>
            <i>.queue_get</i><br/>
            <i>.queue_pop</i><br/>
            <i>.queue_confirm<i><br/>
            <i>.queue_subscribe</i><br/>
            <i>.queue_unsubscribe</i><br/>
            <i>.queue_purge</i><br/>
            <i>.queue_delete</i>
        </td>
        <td>Возможность выполнения всех команд связанных с очередями</td>
    </tr>
    <tr>
        <td>2</td>
        <td>ROUTE_PERM</td>
        <td>1</td>
        <td>
            <i>.route_create</i><br/>
            <i>.route_exist</i><br/>
            <i>.route_list</i><br/>
            <i>.route_keys</i><br/>
            <i>.route_rename</i><br/>
            <i>.route_bind</i><br/>
            <i>.route_unbind</i><br/>
            <i>.route_push</i><br/>
            <i>.route_delete</i>
        </td>
        <td>Возможность выполнения всех команд связанных с маршрутами</td>
    </tr>
    <tr>
        <td>3</td>
        <td>ADMIN_PERM</td>
        <td>5</td>
        <td>-</td>
        <td>Возможность выполнения всех команд на сервере (включая команды для работы с пользователями)</td>
    </tr>
    <tr>
        <td>4</td>
        <td>NOT_CHANGE_PERM</td>
        <td>6</td>
        <td>-</td>
        <td>Если пользователь создан с данным флагом, тогда он не может быть удален</td>
    </tr>
    <tr>
        <td>5</td>
        <td>QUEUE_CREATE_PERM</td>
        <td>20</td>
        <td>.queue_create</td>
        <td>Разрешение на создание очереди</td>
    </tr>
    <tr>
        <td>6</td>
        <td>QUEUE_DECLARE_PERM</td>
        <td>21</td>
        <td>.queue_declare</td>
        <td>Разрешение на декларирование очереди</td>
    </tr>
    <tr>
        <td>7</td>
        <td>QUEUE_EXIST_PERM</td>
        <td>22</td>
        <td>.queue_exist</td>
        <td>Разрешение на проверку существования очереди</td>
    </tr>
    <tr>
        <td>8</td>
        <td>QUEUE_LIST_PERM</td>
        <td>23</td>
        <td>.queue_list</td>
        <td>Разрешение на получение списка очередей</td>
    </tr>
    <tr>
        <td>9</td>
        <td>QUEUE_RENAME_PERM</td>
        <td>24</td>
        <td>.queue_rename</td>
        <td>Разрешение на переименование очереди</td>
    </tr>
    <tr>
        <td>10</td>
        <td>QUEUE_SIZE_PERM</td>
        <td>25</td>
        <td>.queue_size</td>
        <td>Разрешение на получения размера очереди</td>
    </tr>
    <tr>
        <td>11</td>
        <td>QUEUE_PUSH_PERM</td>
        <td>26</td>
        <td>.queue_push</td>
        <td>Разрешение на отправку сообщения в очередь</td>
    </tr>
    <tr>
        <td>12</td>
        <td>QUEUE_GET_PERM</td>
        <td>27</td>
        <td>.queue_get</td>
        <td>Разрешение на получение сообщения из очереди</td>
    </tr>
    <tr>
        <td>13</td>
        <td>QUEUE_POP_PERM</td>
        <td>28</td>
        <td>.queue_pop</td>
        <td>Разрешение на выталкивание сообщения из очереди</td>
    </tr>
    <tr>
        <td>14</td>
        <td>QUEUE_CONFIRM_PERM</td>
        <td>29</td>
        <td>.queue_confirm</td>
        <td>Разрешение на подтверждение сообщения очереди</td>
    </tr>
    <tr>
        <td>15</td>
        <td>QUEUE_SUBSCRIBE_PERM</td>
        <td>30</td>
        <td>.queue_subscribe</td>
        <td>Разрешение на подписку на очередь</td>
    </tr>
    <tr>
        <td>16</td>
        <td>QUEUE_UNSUBSCRIBE_PERM</td>
        <td>31</td>
        <td>.queue_unsubscribe</td>
        <td>Разрешение на отписку на очередь</td>
    </tr>
    <tr>
        <td>17</td>
        <td>QUEUE_PURGE_PERM</td>
        <td>32</td>
        <td>.queue_purge</td>
        <td>Разрешение на удаление всех сообщений из очереди</td>
    </tr>
    <tr>
        <td>18</td>
        <td>QUEUE_DELETE_PERM</td>
        <td>33</td>
        <td>.queue_delete</td>
        <td>Разрешение на удаление очереди</td>
    </tr>
    <tr>
        <td>19</td>
        <td>ROUTE_CREATE_PERM</td>
        <td>34</td>
        <td>.route_create</td>
        <td>Разрешение на создание маршрута</td>
    </tr>
    <tr>
        <td>20</td>
        <td>ROUTE_EXIST_PERM</td>
        <td>35</td>
        <td>.route_exist</td>
        <td>Разрешение на проверку существования маршрута</td>
    </tr>
    <tr>
        <td>21</td>
        <td>ROUTE_LIST_PERM</td>
        <td>36</td>
        <td>.route_list</td>
        <td>Разрешение на получение списка маршрутов</td>
    </tr>
    <tr>
        <td>22</td>
        <td>ROUTE_KEYS_PERM</td>
        <td>37</td>
        <td>.route_keys</td>
        <td>Разрешение на получение списка ключей маршрута</td>
    </tr>
    <tr>
        <td>23</td>
        <td>ROUTE_RENAME_PERM</td>
        <td>38</td>
        <td>.route_rename</td>
        <td>Разрешение на переименование маршрута</td>
    </tr>
    <tr>
        <td>24</td>
        <td>ROUTE_BIND_PERM</td>
        <td>39</td>
        <td>.route_bind</td>
        <td>Разрешение на связывание маршрута с очередью</td>
    </tr>
    <tr>
        <td>25</td>
        <td>ROUTE_UNBIND_PERM</td>
        <td>40</td>
        <td>.route_unbind</td>
        <td>Разрешение на отвязывание маршрута от очереди</td>
    </tr>
    <tr>
        <td>26</td>
        <td>ROUTE_PUSH_PERM</td>
        <td>41</td>
        <td>.route_push</td>
        <td>Разрешение на отправку сообщения в маршрут</td>
    </tr>
    <tr>
        <td>27</td>
        <td>ROUTE_DELETE_PERM</td>
        <td>42</td>
        <td>.route_delete</td>
        <td>Разрешение на удаление маршрута</td>
    </tr>
</table>

Очереди
=======
В EagleMQ очереди являются основным рабочим примитивом. Очереди используются для хранения сообщений и доставки их клиентам.
Очереди могут использоваться в синхронном и асинхронном режиме. В синхронном режиме клиент полностью сам управляет очередью и работает по схеме запрос -> ответ.
В асинхронном режиме сервер может самостоятельно высылать уведомления и сообщения клиенту. Для того чтобы работать в асинхронном режиме нужно стать подписчиком очереди.

Команды для работы с очередями
==============================
* .queue\_create
* .queue\_declare
* .queue\_exist
* .queue\_list
* .queue\_rename
* .queue\_size
* .queue\_push
* .queue\_get
* .queue\_pop
* .queue\_confirm
* .queue\_subscribe
* .queue\_unsubscribe
* .queue\_purge
* .queue\_delete

Описание команд для работы с очередями
====================================
.queue\_create(name, max\_msg, max\_msg\_size, flags)
---------------------------------------------------------------------------------
Команда *.queue\_create* создает очередь с названием *name*,
максимальным количеством сообщений *max\_msg*,
максимальным размером сообщения *max\_msg\_size* и флагами *flags*.

Размер сообщения *max\_msg\_size* не может быть больше 2147483647.
Если размер сообщения *max\_msg\_size* равен 0, то он будет установлен в 2147483647.

Максимальный размер сообщения *max\_msg\_size* указывается в байтах.

Флаги *flags* являются битовой последовательностью.
Очередь поддерживает 4 флага - QUEUE\_AUTODELETE, QUEUE\_FORCE\_PUSH, QUEUE\_ROUND\_ROBIN и QUEUE\_DURABLE.

QUEUE\_AUTODELETE указывает что очередь будет удалена автоматически если клиенты её не используют и она не имеет подписчиков.

QUEUE\_FORCE\_PUSH указывает что если в очереди количество сообщений будет равным *max_msg*,
самое старое сообщение можно удалить, чтобы сохранить более новое.

QUEUE\_ROUND\_ROBIN указывает что каждое сообщение будет отправлено только одному подписчику.
Для распределения сообщений используется алгоритм round-robin.

QUEUE\_DURABLE указывает что очередь и данные в очереди будут сохранятся в хранилище(в соответствии с вашими настройками хранилища).

Название очереди *name* не может иметь длину больше 64.

.queue\_declare(name)
--------------------------------
Команда *.queue\_declare* декларирует очередь с названием *name*.

Декларация означает начало использования очереди.

Если очередь не декларирована клиентом, ему доступны только следующие операции над очередями:

* .queue\_create
* .queue\_declare
* .queue\_exist
* .queue\_list
* .queue\_rename
* .queue\_size
* .queue\_delete

Название очереди *name* не может иметь длину больше 64.

.queue\_exist(name)
-----------------------------
Команда *.queue\_exist* проверяет на существование очередь с названием *name*.

Название очереди *name* не может иметь длину больше 64.

.queue\_list
-----------------
Команда *.queue\_list* используется для получения списка очередей.

Сервер предоставляет следующую информацию о каждой очереди:

* name - название очереди
* max\_msg - максимальное количество сообщений
* max\_msg\_size - максимальный размер сообщения
* flags - флаги с которыми очередь была создана
* size - количество сообщений в очереди
* declared clients - количество клиентов которые продекларировали очередь
* subscribed clients - количество клиентов которые подписаны на очередь

.queue\_rename(from, to)
--------------------------
Команда *.queue\_rename* переименовывает очередь с названием *from* в *to*.

Название очереди *from* и *to* не может иметь длину больше 64.

.queue\_size(name)
----------------------------
Команда *.queue\_size* возвращает количество сообщений в очереди с названием *name*.

Название очереди *name* не может иметь длину больше 64.

.queue\_push(name, message)
---------------------------------------------
Команда *.queue\_push* отправляет сообщение *message* в очередь с названием *name*.

Название очереди *name* не может иметь длину больше 64.

.queue\_get(name)
---------------------------
Команда *.queue\_get* получает самое старое сообщение которое было отправлено в очередь с названием *name*.

Данная команда не изменяет очередь.

Название очереди *name* не может иметь длину больше 64.

.queue\_pop(name, timeout)
----------------------------
Команда *.queue\_pop* выталкивает самое старое сообщение которое было отправлено в очередь с названием *name*.

*timeout* указывает время ожидания подтверждения доставки в милисекундах. Если за указанное время сообщение не будет подтверждено, сообщение будет возвращено в очередь как самое старое.

Если *timeout* имеет значение 0, сообщение в подтверждении доставки не нуждается.

Название очереди *name* не может иметь длину больше 64.

.queue\_confirm(name, tag)
--------------------------------
Команда *.queue\_confirm* подтверждает доставку сообщения.

Название очереди *name* не может иметь длину больше 64.

.queue\_subscribe(name, flags)
---------------------------------------------
Команда *.queue\_subscribe* подписывает клиента на очередь с названием *name* используя флаги *flags*.

Подписка на очередь означает уведомление клиента после некоторого события произошедшего с очередью.
Подписка меняет поведение очереди.

Флаги *flags* являются битовой последовательностью.
Флаги *flags* могут принимать 2 значения - QUEUE\_SUBSCRIBE\_MSG или QUEUE\_SUBSCRIBE\_NOTIFY.

Если совершена подписка с флагом QUEUE\_SUBSCRIBE\_MSG,
тогда после каждой команды *.queue\_push* клиенту автоматически высылается сообщение которое отправлено в очередь.
Сообщение высылается всем клиентам которые которые подписаны на очередь с этим флагом.
Если имеется хоть 1 подписчик на очередь с флагом QUEUE\_SUBSCRIBE\_MSG,
тогда сообщение не будет попадать в очередь т.к. будет выслано клиенту.

Если совершена подписка с флагом QUEUE\_SUBSCRIBE\_NOTIFY,
тогда после каждой команды *.queue\_push* клиенту высылается уведомление о том,
что эта очередь получила новое сообщение.
Уведомление высылается всем клиентам которые которые подписаны на очередь с этим флагом.

Название очереди *name* не может иметь длину больше 64.

.queue\_unsubscribe(name)
----------------------------------------
Команда *.queue\_unsubscribe* удаляет клиента из списка подписчиков очереди с названием *name*.

Название очереди *name* не может иметь длину больше 64.

.queue\_purge(name)
-------------------------------
Команда *.queue\_purge* удаляет все сообщения в очереди с названием *name*.

Название очереди *name* не может иметь длину больше 64.

.queue\_delete(name)
--------------------------------
Команда *.queue\_delete* удаляет очередь с названием *name*.

При выполнении команды все сообщения очереди удаляются.
Все клиенты которые подписаны на очередь удаляются из списка подписчиков.

Название очереди *name* не может иметь длину больше 64.

Маршруты
========
Маршруты позволяют распределять входящие сообщения по очередям.
Для распределения сообщения нужно связать очередь с ключом и при отправке указать ключ.

Команды для работы с маршрутами
===============================
* .route\_create
* .route\_exist
* .route\_list
* .route\_rename
* .route\_keys
* .route\_bind
* .route\_unbind
* .route\_push
* .route\_delete

Описание команд для работы с маршрутами
=======================================
.route\_create(name, flags)
---------------------------
Команда *.route\_create* создает маршрут с названием *name* и флагами *flags*.

Флаги *flags* являются битовой последовательностью. Маршрут поддерживает 3 флага - ROUTE\_AUTODELETE, ROUTE\_ROUND_ROBIN и ROUTE\_DURABLE.

ROUTE\_AUTODELETE указывает что маршрут будет удален автоматически если ни одна очередь с ним не связана.

ROUTE\_ROUND\_ROBIN указывает что каждое сообщение будет отправлено только одной очереди связанной по ключу.
Для распределения сообщений используется алгоритм round-robin.

ROUTE\_DURABLE указывает что маршрут будет сохранятся в хранилище(в соответствии с вашими настройками хранилища).

Название маршрута *name* не может иметь длину больше 64.

.route\_exist(name)
-------------------
Команда *.route_exist* проверяет на существование маршрут с названием *name*.

Название маршрута *name* не может иметь длину больше 64.

.route\_list
------------
Команда *.route_list* используется для получения списка маршрутов.

Сервер предоставляет следующую информацию о каждом маршруте:

* name - название маршрута
* flags - флаги с которыми маршрут был создан
* keys - количество ключей в маршруте

.route\_keys(name)
------------------
Команда *.route_keys* получает список всех ключей маршрута с названием *name*.

Сервер предоставляет следующую информацию о каждом ключе:

* key - ключ
* queue - связанная очередь

Название маршрута *name* не может иметь длину больше 64.

.route\_rename(from, to)
--------------------------
Команда *.route\_rename* переименовывает маршрут с названием *from* в *to*.

Название маршрута *from* и *to* не может иметь длину больше 64.

.route\_bind(name, queue, key)
------------------------------
Команда *.route\_bind* связывает маршрут с названием *name* с очередью *queue* по ключу *key*.

Название маршрута *name* не может иметь длину больше 64.

Название очереди *queue* не может иметь длину больше 64.

Ключ *key* не может иметь длину больше 32.

.route\_unbind(name, queue, key)
--------------------------------
Команда *.route\_unbind* отвязывает маршрут с названием *name* от очереди *queue* по ключу *key*.

Название маршрута *name* не может иметь длину больше 64.

Название очереди *queue* не может иметь длину больше 64.

Ключ *key* не может иметь длину больше 32.

.route\_push(name, key, message)
--------------------------------
Команда *.route\_push* отправляет сообщение *message* в маршрут с названием *name* по ключу *key*.

Название маршрута *name* не может иметь длину больше 64.

Ключ *key* не может иметь длину больше 32.

.route\_delete(name)
--------------------
Команда *.route\_delete* удаляет маршрут с названием *name*.

При выполнении команды все связи с очередями удаляются.

Название маршрута *name* не может иметь длину больше 64.